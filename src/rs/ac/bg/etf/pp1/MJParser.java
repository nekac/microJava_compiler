
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Fri Feb 10 21:21:17 CET 2017
//----------------------------------------------------

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import java.util.*;
import rs.etf.pp1.mj.runtime.Code;
import rs.etf.pp1.symboltable.visitors.DumpSymbolTableVisitor;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Fri Feb 10 21:21:17 CET 2017
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\236\000\002\004\010\000\002\002\004\000\002\047" +
    "\003\000\002\003\004\000\002\003\002\000\002\002\003" +
    "\000\002\002\003\000\002\002\003\000\002\070\002\000" +
    "\002\021\007\000\002\021\005\000\002\022\005\000\002" +
    "\022\003\000\002\023\005\000\002\066\003\000\002\066" +
    "\003\000\002\066\003\000\002\071\002\000\002\007\006" +
    "\000\002\007\005\000\002\007\005\000\002\006\005\000" +
    "\002\006\003\000\002\010\003\000\002\010\005\000\002" +
    "\072\002\000\002\017\011\000\002\073\002\000\002\017" +
    "\013\000\002\074\002\000\002\017\013\000\002\020\005" +
    "\000\002\020\003\000\002\020\002\000\002\016\004\000" +
    "\002\016\002\000\002\075\002\000\002\013\006\000\002" +
    "\013\005\000\002\013\004\000\002\014\005\000\002\014" +
    "\003\000\002\015\003\000\002\015\005\000\002\011\004" +
    "\000\002\011\002\000\002\076\002\000\002\077\002\000" +
    "\002\012\016\000\002\100\002\000\002\101\002\000\002" +
    "\012\016\000\002\044\003\000\002\044\002\000\002\025" +
    "\003\000\002\025\002\000\002\025\003\000\002\060\005" +
    "\000\002\060\005\000\002\060\003\000\002\024\004\000" +
    "\002\024\006\000\002\062\003\000\002\031\004\000\002" +
    "\031\002\000\002\030\003\000\002\030\003\000\002\046" +
    "\003\000\002\046\002\000\002\045\003\000\002\045\002" +
    "\000\002\005\012\000\002\005\012\000\002\005\012\000" +
    "\002\005\012\000\002\005\006\000\002\036\004\000\002" +
    "\036\005\000\002\036\004\000\002\041\006\000\002\041" +
    "\006\000\002\042\004\000\002\035\004\000\002\035\005" +
    "\000\002\035\004\000\002\035\007\000\002\035\007\000" +
    "\002\035\011\000\002\035\004\000\002\035\004\000\002" +
    "\035\005\000\002\035\004\000\002\035\005\000\002\102" +
    "\002\000\002\037\006\000\002\037\005\000\002\103\002" +
    "\000\002\037\010\000\002\037\004\000\002\040\003\000" +
    "\002\040\002\000\002\032\003\000\002\032\003\000\002" +
    "\026\003\000\002\026\002\000\002\026\003\000\002\027" +
    "\005\000\002\027\003\000\002\033\005\000\002\033\003" +
    "\000\002\034\005\000\002\034\003\000\002\067\005\000" +
    "\002\067\003\000\002\104\002\000\002\064\006\000\002" +
    "\064\003\000\002\064\004\000\002\105\002\000\002\063" +
    "\006\000\002\063\003\000\002\065\003\000\002\065\003" +
    "\000\002\065\005\000\002\065\003\000\002\065\005\000" +
    "\002\065\003\000\002\065\006\000\002\043\005\000\002" +
    "\043\002\000\002\106\002\000\002\050\007\000\002\050" +
    "\006\000\002\050\005\000\002\050\003\000\002\061\003" +
    "\000\002\061\003\000\002\061\003\000\002\051\003\000" +
    "\002\051\003\000\002\051\003\000\002\051\003\000\002" +
    "\051\003\000\002\051\003\000\002\052\003\000\002\052" +
    "\003\000\002\054\003\000\002\054\003\000\002\053\003" +
    "\000\002\053\003\000\002\055\003\000\002\055\003\000" +
    "\002\057\003\000\002\057\003\000\002\057\003\000\002" +
    "\056\003\000\002\056\003\000\002\056\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u0110\000\004\004\005\001\002\000\004\002\u0112\001" +
    "\002\000\004\024\006\001\002\000\012\015\uffff\017\uffff" +
    "\024\uffff\031\uffff\001\002\000\012\015\ufffd\017\ufffd\024" +
    "\ufffd\031\ufffd\001\002\000\012\015\021\017\020\024\014" +
    "\031\013\001\002\000\006\003\u0107\024\ufff0\001\002\000" +
    "\012\015\ufffe\017\ufffe\024\ufffe\031\ufffe\001\002\000\012" +
    "\012\uffd4\024\uffd4\032\uffd4\063\uffd4\001\002\000\064\003" +
    "\uffc3\024\uffc3\025\uffc3\026\uffc3\027\uffc3\030\uffc3\033\uffc3" +
    "\035\uffc3\036\uffc3\037\uffc3\040\uffc3\043\uffc3\044\uffc3\045" +
    "\uffc3\046\uffc3\047\uffc3\050\uffc3\051\uffc3\052\uffc3\053\uffc3" +
    "\054\uffc3\055\uffc3\056\uffc3\057\uffc3\060\uffc3\001\002\000" +
    "\012\015\ufffc\017\ufffc\024\ufffc\031\ufffc\001\002\000\012" +
    "\015\ufffa\017\ufffa\024\ufffa\031\ufffa\001\002\000\012\015" +
    "\ufffb\017\ufffb\024\ufffb\031\ufffb\001\002\000\004\024\041" +
    "\001\002\000\006\003\023\024\014\001\002\000\004\024" +
    "\ufff9\001\002\000\004\033\024\001\002\000\012\015\ufff7" +
    "\017\ufff7\024\ufff7\031\ufff7\001\002\000\004\024\030\001" +
    "\002\000\006\033\037\040\036\001\002\000\006\033\ufff5" +
    "\040\ufff5\001\002\000\004\041\031\001\002\000\010\021" +
    "\034\022\035\023\032\001\002\000\006\033\ufff1\040\ufff1" +
    "\001\002\000\006\033\ufff4\040\ufff4\001\002\000\006\033" +
    "\ufff3\040\ufff3\001\002\000\006\033\ufff2\040\ufff2\001\002" +
    "\000\004\024\030\001\002\000\012\015\ufff8\017\ufff8\024" +
    "\ufff8\031\ufff8\001\002\000\006\033\ufff6\040\ufff6\001\002" +
    "\000\006\016\043\031\uffe8\001\002\000\004\031\u0100\001" +
    "\002\000\006\003\044\024\045\001\002\000\004\031\373" +
    "\001\002\000\004\031\uffe6\001\002\000\004\031\047\001" +
    "\002\000\012\003\uffde\024\uffde\031\uffde\032\uffde\001\002" +
    "\000\012\003\054\024\014\031\051\032\uffe0\001\002\000" +
    "\012\012\uffd4\024\uffd4\032\uffd4\063\uffd4\001\002\000\012" +
    "\003\uffdf\024\uffdf\031\uffdf\032\uffdf\001\002\000\006\003" +
    "\057\024\uffdd\001\002\000\004\032\uffe1\001\002\000\004" +
    "\032\056\001\002\000\012\015\uffe5\017\uffe5\024\uffe5\031" +
    "\uffe5\001\002\000\014\003\uffda\024\uffda\031\uffda\032\uffda" +
    "\033\071\001\002\000\004\024\063\001\002\000\006\033" +
    "\067\040\066\001\002\000\006\033\uffd8\040\uffd8\001\002" +
    "\000\010\033\uffd7\036\064\040\uffd7\001\002\000\004\037" +
    "\065\001\002\000\006\033\uffd6\040\uffd6\001\002\000\004" +
    "\024\063\001\002\000\012\003\uffdc\024\uffdc\031\uffdc\032" +
    "\uffdc\001\002\000\006\033\uffd9\040\uffd9\001\002\000\012" +
    "\003\uffdb\024\uffdb\031\uffdb\032\uffdb\001\002\000\012\012" +
    "\uffcc\024\uffcc\032\075\063\074\001\002\000\006\012\100" +
    "\024\014\001\002\000\006\012\uffcd\024\uffcd\001\002\000" +
    "\004\032\uffe2\001\002\000\012\012\uffd5\024\uffd5\032\uffd5" +
    "\063\uffd5\001\002\000\004\024\361\001\002\000\004\024" +
    "\101\001\002\000\004\034\uffd0\001\002\000\004\034\103" +
    "\001\002\000\010\003\105\024\014\035\uffca\001\002\000" +
    "\004\024\356\001\002\000\006\035\uffc9\040\354\001\002" +
    "\000\006\035\uffcb\040\352\001\002\000\004\035\111\001" +
    "\002\000\006\035\uffc6\040\uffc6\001\002\000\006\024\uffde" +
    "\031\uffde\001\002\000\006\024\014\031\113\001\002\000" +
    "\026\005\uffcf\006\uffcf\007\uffcf\010\uffcf\011\uffcf\013\uffcf" +
    "\024\uffcf\031\uffcf\032\uffcf\064\uffcf\001\002\000\026\005" +
    "\uffc1\006\uffc1\007\uffc1\010\uffc1\011\uffc1\013\uffc1\024\uffc1" +
    "\031\uffc1\032\uffc1\064\uffc1\001\002\000\026\005\131\006" +
    "\136\007\133\010\116\011\134\013\125\024\120\031\117" +
    "\032\135\064\121\001\002\000\004\034\346\001\002\000" +
    "\026\005\uffc1\006\uffc1\007\uffc1\010\uffc1\011\uffc1\013\uffc1" +
    "\024\uffc1\031\uffc1\032\uffc1\064\uffc1\001\002\000\072\025" +
    "\uff7b\026\uff7b\027\uff7b\030\uff7b\033\uff7b\034\uff7b\035\uff7b" +
    "\036\uff7b\037\uff7b\040\uff7b\041\uff7b\042\uff7b\043\uff7b\044" +
    "\uff7b\045\uff7b\046\uff7b\047\uff7b\050\uff7b\051\uff7b\052\uff7b" +
    "\053\uff7b\054\uff7b\055\uff7b\056\uff7b\057\uff7b\060\uff7b\061" +
    "\uff7b\062\uff7b\001\002\000\004\034\316\001\002\000\026" +
    "\005\uffbf\006\uffbf\007\uffbf\010\uffbf\011\uffbf\013\uffbf\024" +
    "\uffbf\031\uffbf\032\uffbf\064\uffbf\001\002\000\030\026\161" +
    "\030\154\034\uffa1\036\202\041\302\042\203\052\172\054" +
    "\167\056\176\061\304\062\303\001\002\000\024\005\131" +
    "\006\136\007\133\010\116\011\134\013\125\024\120\031" +
    "\117\064\121\001\002\000\004\034\244\001\002\000\026" +
    "\005\uffc2\006\uffc2\007\uffc2\010\uffc2\011\uffc2\013\uffc2\024" +
    "\uffc2\031\uffc2\032\uffc2\064\uffc2\001\002\000\004\033\243" +
    "\001\002\000\024\005\131\006\136\007\133\010\116\011" +
    "\134\013\125\024\120\031\117\064\121\001\002\000\004" +
    "\034\231\001\002\000\026\005\uffc0\006\uffc0\007\uffc0\010" +
    "\uffc0\011\uffc0\013\uffc0\024\uffc0\031\uffc0\032\uffc0\064\uffc0" +
    "\001\002\000\004\033\230\001\002\000\022\020\141\021" +
    "\144\022\150\023\146\024\120\027\140\033\145\034\152" +
    "\001\002\000\012\012\uffce\024\uffce\032\uffce\063\uffce\001" +
    "\002\000\004\033\137\001\002\000\030\005\uffa9\006\uffa9" +
    "\007\uffa9\010\uffa9\011\uffa9\013\uffa9\014\uffa9\024\uffa9\031" +
    "\uffa9\032\uffa9\064\uffa9\001\002\000\016\020\141\021\144" +
    "\022\150\023\146\024\120\034\152\001\002\000\004\024" +
    "\014\001\002\000\014\025\156\026\161\027\157\030\154" +
    "\033\221\001\002\000\064\025\uff83\026\uff83\027\uff83\030" +
    "\uff83\033\uff83\034\201\035\uff83\036\202\037\uff83\040\uff83" +
    "\042\203\043\uff83\044\uff83\045\uff83\046\uff83\047\uff83\050" +
    "\uff83\051\uff83\052\uff83\053\uff83\054\uff83\055\uff83\056\uff83" +
    "\057\uff83\060\uff83\001\002\000\056\025\uff88\026\uff88\027" +
    "\uff88\030\uff88\033\uff88\035\uff88\037\uff88\040\uff88\043\uff88" +
    "\044\uff88\045\uff88\046\uff88\047\uff88\050\uff88\051\uff88\052" +
    "\uff88\053\uff88\054\uff88\055\uff88\056\uff88\057\uff88\060\uff88" +
    "\001\002\000\030\005\uffa6\006\uffa6\007\uffa6\010\uffa6\011" +
    "\uffa6\013\uffa6\014\uffa6\024\uffa6\031\uffa6\032\uffa6\064\uffa6" +
    "\001\002\000\056\025\uff85\026\uff85\027\uff85\030\uff85\033" +
    "\uff85\035\uff85\037\uff85\040\uff85\043\uff85\044\uff85\045\uff85" +
    "\046\uff85\047\uff85\050\uff85\051\uff85\052\uff85\053\uff85\054" +
    "\uff85\055\uff85\056\uff85\057\uff85\060\uff85\001\002\000\056" +
    "\025\uff8d\026\uff8d\027\uff8d\030\uff8d\033\uff8d\035\uff8d\037" +
    "\uff8d\040\uff8d\043\uff8d\044\uff8d\045\uff8d\046\uff8d\047\uff8d" +
    "\050\uff8d\051\175\052\172\053\171\054\167\055\170\056" +
    "\176\057\uff8d\060\uff8d\001\002\000\056\025\uff87\026\uff87" +
    "\027\uff87\030\uff87\033\uff87\035\uff87\037\uff87\040\uff87\043" +
    "\uff87\044\uff87\045\uff87\046\uff87\047\uff87\050\uff87\051\uff87" +
    "\052\uff87\053\uff87\054\uff87\055\uff87\056\uff87\057\uff87\060" +
    "\uff87\001\002\000\056\025\uff89\026\uff89\027\uff89\030\uff89" +
    "\033\uff89\035\uff89\037\uff89\040\uff89\043\uff89\044\uff89\045" +
    "\uff89\046\uff89\047\uff89\050\uff89\051\uff89\052\uff89\053\uff89" +
    "\054\uff89\055\uff89\056\uff89\057\uff89\060\uff89\001\002\000" +
    "\020\020\141\021\144\022\150\023\146\024\120\027\140" +
    "\034\152\001\002\000\014\025\156\026\161\027\157\030" +
    "\154\035\155\001\002\000\022\003\uff6c\020\uff6c\021\uff6c" +
    "\022\uff6c\023\uff6c\024\uff6c\027\uff6c\034\uff6c\001\002\000" +
    "\056\025\uff86\026\uff86\027\uff86\030\uff86\033\uff86\035\uff86" +
    "\037\uff86\040\uff86\043\uff86\044\uff86\045\uff86\046\uff86\047" +
    "\uff86\050\uff86\051\uff86\052\uff86\053\uff86\054\uff86\055\uff86" +
    "\056\uff86\057\uff86\060\uff86\001\002\000\016\020\uff6f\021" +
    "\uff6f\022\uff6f\023\uff6f\024\uff6f\034\uff6f\001\002\000\016" +
    "\020\uff6e\021\uff6e\022\uff6e\023\uff6e\024\uff6e\034\uff6e\001" +
    "\002\000\016\020\uff71\021\uff71\022\uff71\023\uff71\024\uff71" +
    "\034\uff71\001\002\000\022\003\uff6d\020\uff6d\021\uff6d\022" +
    "\uff6d\023\uff6d\024\uff6d\027\uff6d\034\uff6d\001\002\000\016" +
    "\020\uff8f\021\uff8f\022\uff8f\023\uff8f\024\uff8f\034\uff8f\001" +
    "\002\000\016\020\uff70\021\uff70\022\uff70\023\uff70\024\uff70" +
    "\034\uff70\001\002\000\016\020\141\021\144\022\150\023" +
    "\146\024\120\034\152\001\002\000\056\025\uff8e\026\uff8e" +
    "\027\uff8e\030\uff8e\033\uff8e\035\uff8e\037\uff8e\040\uff8e\043" +
    "\uff8e\044\uff8e\045\uff8e\046\uff8e\047\uff8e\050\uff8e\051\175" +
    "\052\172\053\171\054\167\055\170\056\176\057\uff8e\060" +
    "\uff8e\001\002\000\016\020\uff6b\021\uff6b\022\uff6b\023\uff6b" +
    "\024\uff6b\034\uff6b\001\002\000\022\003\uff65\020\uff65\021" +
    "\uff65\022\uff65\023\uff65\024\uff65\027\uff65\034\uff65\001\002" +
    "\000\016\020\uff67\021\uff67\022\uff67\023\uff67\024\uff67\034" +
    "\uff67\001\002\000\016\020\uff68\021\uff68\022\uff68\023\uff68" +
    "\024\uff68\034\uff68\001\002\000\022\003\uff66\020\uff66\021" +
    "\uff66\022\uff66\023\uff66\024\uff66\027\uff66\034\uff66\001\002" +
    "\000\016\020\uff8b\021\uff8b\022\uff8b\023\uff8b\024\uff8b\034" +
    "\uff8b\001\002\000\016\020\uff6a\021\uff6a\022\uff6a\023\uff6a" +
    "\024\uff6a\034\uff6a\001\002\000\016\020\uff69\021\uff69\022" +
    "\uff69\023\uff69\024\uff69\034\uff69\001\002\000\022\003\uff64" +
    "\020\uff64\021\uff64\022\uff64\023\uff64\024\uff64\027\uff64\034" +
    "\uff64\001\002\000\016\020\141\021\144\022\150\023\146" +
    "\024\120\034\152\001\002\000\056\025\uff8a\026\uff8a\027" +
    "\uff8a\030\uff8a\033\uff8a\035\uff8a\037\uff8a\040\uff8a\043\uff8a" +
    "\044\uff8a\045\uff8a\046\uff8a\047\uff8a\050\uff8a\051\uff8a\052" +
    "\uff8a\053\uff8a\054\uff8a\055\uff8a\056\uff8a\057\uff8a\060\uff8a" +
    "\001\002\000\024\003\214\020\141\021\144\022\150\023" +
    "\146\024\120\027\140\034\152\035\uff99\001\002\000\022" +
    "\003\205\020\uff7f\021\uff7f\022\uff7f\023\uff7f\024\uff7f\027" +
    "\uff7f\034\uff7f\001\002\000\004\024\204\001\002\000\072" +
    "\025\uff7c\026\uff7c\027\uff7c\030\uff7c\033\uff7c\034\uff7c\035" +
    "\uff7c\036\uff7c\037\uff7c\040\uff7c\041\uff7c\042\uff7c\043\uff7c" +
    "\044\uff7c\045\uff7c\046\uff7c\047\uff7c\050\uff7c\051\uff7c\052" +
    "\uff7c\053\uff7c\054\uff7c\055\uff7c\056\uff7c\057\uff7c\060\uff7c" +
    "\061\uff7c\062\uff7c\001\002\000\004\037\211\001\002\000" +
    "\020\020\141\021\144\022\150\023\146\024\120\027\140" +
    "\034\152\001\002\000\014\025\156\026\161\027\157\030" +
    "\154\037\210\001\002\000\072\025\uff7e\026\uff7e\027\uff7e" +
    "\030\uff7e\033\uff7e\034\uff7e\035\uff7e\036\uff7e\037\uff7e\040" +
    "\uff7e\041\uff7e\042\uff7e\043\uff7e\044\uff7e\045\uff7e\046\uff7e" +
    "\047\uff7e\050\uff7e\051\uff7e\052\uff7e\053\uff7e\054\uff7e\055" +
    "\uff7e\056\uff7e\057\uff7e\060\uff7e\061\uff7e\062\uff7e\001\002" +
    "\000\072\025\uff7d\026\uff7d\027\uff7d\030\uff7d\033\uff7d\034" +
    "\uff7d\035\uff7d\036\uff7d\037\uff7d\040\uff7d\041\uff7d\042\uff7d" +
    "\043\uff7d\044\uff7d\045\uff7d\046\uff7d\047\uff7d\050\uff7d\051" +
    "\uff7d\052\uff7d\053\uff7d\054\uff7d\055\uff7d\056\uff7d\057\uff7d" +
    "\060\uff7d\061\uff7d\062\uff7d\001\002\000\004\035\220\001" +
    "\002\000\016\025\156\026\161\027\157\030\154\035\uff96" +
    "\040\uff96\001\002\000\004\035\uff98\001\002\000\006\035" +
    "\uff9a\040\216\001\002\000\020\020\141\021\144\022\150" +
    "\023\146\024\120\027\140\034\152\001\002\000\016\025" +
    "\156\026\161\027\157\030\154\035\uff97\040\uff97\001\002" +
    "\000\056\025\uff82\026\uff82\027\uff82\030\uff82\033\uff82\035" +
    "\uff82\037\uff82\040\uff82\043\uff82\044\uff82\045\uff82\046\uff82" +
    "\047\uff82\050\uff82\051\uff82\052\uff82\053\uff82\054\uff82\055" +
    "\uff82\056\uff82\057\uff82\060\uff82\001\002\000\030\005\uffa7" +
    "\006\uffa7\007\uffa7\010\uffa7\011\uffa7\013\uffa7\014\uffa7\024" +
    "\uffa7\031\uffa7\032\uffa7\064\uffa7\001\002\000\060\025\uff80" +
    "\026\uff80\027\uff80\030\uff80\033\uff80\035\uff80\036\224\037" +
    "\uff80\040\uff80\043\uff80\044\uff80\045\uff80\046\uff80\047\uff80" +
    "\050\uff80\051\uff80\052\uff80\053\uff80\054\uff80\055\uff80\056" +
    "\uff80\057\uff80\060\uff80\001\002\000\056\025\uff84\026\uff84" +
    "\027\uff84\030\uff84\033\uff84\035\uff84\037\uff84\040\uff84\043" +
    "\uff84\044\uff84\045\uff84\046\uff84\047\uff84\050\uff84\051\uff84" +
    "\052\uff84\053\uff84\054\uff84\055\uff84\056\uff84\057\uff84\060" +
    "\uff84\001\002\000\020\020\141\021\144\022\150\023\146" +
    "\024\120\027\140\034\152\001\002\000\014\025\156\026" +
    "\161\027\157\030\154\037\226\001\002\000\056\025\uff81" +
    "\026\uff81\027\uff81\030\uff81\033\uff81\035\uff81\037\uff81\040" +
    "\uff81\043\uff81\044\uff81\045\uff81\046\uff81\047\uff81\050\uff81" +
    "\051\uff81\052\uff81\053\uff81\054\uff81\055\uff81\056\uff81\057" +
    "\uff81\060\uff81\001\002\000\056\025\uff8c\026\uff8c\027\uff8c" +
    "\030\uff8c\033\uff8c\035\uff8c\037\uff8c\040\uff8c\043\uff8c\044" +
    "\uff8c\045\uff8c\046\uff8c\047\uff8c\050\uff8c\051\175\052\172" +
    "\053\171\054\167\055\170\056\176\057\uff8c\060\uff8c\001" +
    "\002\000\030\005\uffa8\006\uffa8\007\uffa8\010\uffa8\011\uffa8" +
    "\013\uffa8\014\uffa8\024\uffa8\031\uffa8\032\uffa8\064\uffa8\001" +
    "\002\000\020\020\141\021\144\022\150\023\146\024\120" +
    "\027\140\034\152\001\002\000\016\025\156\026\161\027" +
    "\157\030\154\035\234\040\233\001\002\000\004\021\236" +
    "\001\002\000\004\033\235\001\002\000\030\005\uffab\006" +
    "\uffab\007\uffab\010\uffab\011\uffab\013\uffab\014\uffab\024\uffab" +
    "\031\uffab\032\uffab\064\uffab\001\002\000\004\035\237\001" +
    "\002\000\004\033\240\001\002\000\030\005\uffaa\006\uffaa" +
    "\007\uffaa\010\uffaa\011\uffaa\013\uffaa\014\uffaa\024\uffaa\031" +
    "\uffaa\032\uffaa\064\uffaa\001\002\000\026\005\uffb3\006\uffb3" +
    "\007\uffb3\010\uffb3\011\uffb3\013\uffb3\024\uffb3\031\uffb3\032" +
    "\uffb3\064\uffb3\001\002\000\030\005\uffad\006\uffad\007\uffad" +
    "\010\uffad\011\uffad\013\uffad\014\uffad\024\uffad\031\uffad\032" +
    "\uffad\064\uffad\001\002\000\030\005\uffaf\006\uffaf\007\uffaf" +
    "\010\uffaf\011\uffaf\013\uffaf\014\uffaf\024\uffaf\031\uffaf\032" +
    "\uffaf\064\uffaf\001\002\000\022\003\250\020\141\021\144" +
    "\022\150\023\146\024\120\027\140\034\152\001\002\000" +
    "\036\025\156\026\161\027\157\030\154\033\uff90\035\uff90" +
    "\043\260\044\265\045\261\046\266\047\264\050\263\057" +
    "\uff90\060\uff90\001\002\000\006\035\255\060\256\001\002" +
    "\000\012\033\uff92\035\uff92\057\uff92\060\uff92\001\002\000" +
    "\004\035\254\001\002\000\012\033\uff94\035\uff94\057\252" +
    "\060\uff94\001\002\000\020\020\141\021\144\022\150\023" +
    "\146\024\120\027\140\034\152\001\002\000\012\033\uff93" +
    "\035\uff93\057\uff93\060\uff93\001\002\000\024\005\uffb1\006" +
    "\uffb1\007\uffb1\010\uffb1\011\uffb1\013\uffb1\024\uffb1\031\uffb1" +
    "\064\uffb1\001\002\000\024\005\uffb2\006\uffb2\007\uffb2\010" +
    "\uffb2\011\uffb2\013\uffb2\024\uffb2\031\uffb2\064\uffb2\001\002" +
    "\000\020\020\141\021\144\022\150\023\146\024\120\027" +
    "\140\034\152\001\002\000\012\033\uff95\035\uff95\057\252" +
    "\060\uff95\001\002\000\020\020\uff77\021\uff77\022\uff77\023" +
    "\uff77\024\uff77\027\uff77\034\uff77\001\002\000\020\020\uff75" +
    "\021\uff75\022\uff75\023\uff75\024\uff75\027\uff75\034\uff75\001" +
    "\002\000\020\020\141\021\144\022\150\023\146\024\120" +
    "\027\140\034\152\001\002\000\020\020\uff72\021\uff72\022" +
    "\uff72\023\uff72\024\uff72\027\uff72\034\uff72\001\002\000\020" +
    "\020\uff73\021\uff73\022\uff73\023\uff73\024\uff73\027\uff73\034" +
    "\uff73\001\002\000\020\020\uff76\021\uff76\022\uff76\023\uff76" +
    "\024\uff76\027\uff76\034\uff76\001\002\000\020\020\uff74\021" +
    "\uff74\022\uff74\023\uff74\024\uff74\027\uff74\034\uff74\001\002" +
    "\000\022\025\156\026\161\027\157\030\154\033\uff91\035" +
    "\uff91\057\uff91\060\uff91\001\002\000\024\005\131\006\136" +
    "\007\133\010\116\011\134\013\125\024\120\031\117\064" +
    "\121\001\002\000\026\005\uffb5\006\uffb5\007\uffb5\010\uffb5" +
    "\011\uffb5\013\uffb5\024\uffb5\031\uffb5\032\uffb5\064\uffb5\001" +
    "\002\000\030\005\uffc0\006\uffc0\007\uffc0\010\uffc0\011\uffc0" +
    "\013\uffc0\014\273\024\uffc0\031\uffc0\032\uffc0\064\uffc0\001" +
    "\002\000\024\005\uffb0\006\uffb0\007\uffb0\010\uffb0\011\uffb0" +
    "\013\uffb0\024\uffb0\031\uffb0\064\uffb0\001\002\000\026\005" +
    "\uffb4\006\uffb4\007\uffb4\010\uffb4\011\uffb4\013\uffb4\024\uffb4" +
    "\031\uffb4\032\uffb4\064\uffb4\001\002\000\030\005\uffae\006" +
    "\uffae\007\uffae\010\uffae\011\uffae\013\uffae\014\uffae\024\uffae" +
    "\031\uffae\032\uffae\064\uffae\001\002\000\022\003\uff78\020" +
    "\uff78\021\uff78\022\uff78\023\uff78\024\uff78\027\uff78\034\uff78" +
    "\001\002\000\022\003\uff79\020\uff79\021\uff79\022\uff79\023" +
    "\uff79\024\uff79\027\uff79\034\uff79\001\002\000\022\003\314" +
    "\020\uffa4\021\uffa4\022\uffa4\023\uffa4\024\uffa4\027\uffa4\034" +
    "\uffa4\001\002\000\006\033\uff9f\035\uff9f\001\002\000\022" +
    "\003\uff7a\020\uff7a\021\uff7a\022\uff7a\023\uff7a\024\uff7a\027" +
    "\uff7a\034\uff7a\001\002\000\006\033\uff9b\035\uff9b\001\002" +
    "\000\006\033\uff9c\035\uff9c\001\002\000\004\034\306\001" +
    "\002\000\024\003\214\020\141\021\144\022\150\023\146" +
    "\024\120\027\140\034\152\035\uff99\001\002\000\004\035" +
    "\310\001\002\000\010\003\311\033\uff9d\035\uff9d\001\002" +
    "\000\006\033\uff9e\035\uff9e\001\002\000\006\033\uffa0\035" +
    "\uffa0\001\002\000\020\020\141\021\144\022\150\023\146" +
    "\024\120\027\140\034\152\001\002\000\006\033\uffa2\035" +
    "\uffa2\001\002\000\016\025\156\026\161\027\157\030\154" +
    "\033\uffa3\035\uffa3\001\002\000\010\003\320\024\120\033" +
    "\uffbd\001\002\000\004\033\331\001\002\000\006\033\323" +
    "\035\322\001\002\000\006\033\uffbe\035\uffbe\001\002\000" +
    "\024\005\uffb6\006\uffb6\007\uffb6\010\uffb6\011\uffb6\013\uffb6" +
    "\024\uffb6\031\uffb6\064\uffb6\001\002\000\022\020\141\021" +
    "\144\022\150\023\146\024\120\027\140\033\uffbb\034\152" +
    "\001\002\000\006\033\uffbc\060\256\001\002\000\004\033" +
    "\326\001\002\000\006\024\120\035\uffbd\001\002\000\004" +
    "\035\330\001\002\000\024\005\uffb9\006\uffb9\007\uffb9\010" +
    "\uffb9\011\uffb9\013\uffb9\024\uffb9\031\uffb9\064\uffb9\001\002" +
    "\000\024\003\333\020\141\021\144\022\150\023\146\024" +
    "\120\027\140\033\uffbb\034\152\001\002\000\004\033\337" +
    "\001\002\000\004\033\334\001\002\000\006\024\120\035" +
    "\uffbd\001\002\000\004\035\336\001\002\000\024\005\uffb8" +
    "\006\uffb8\007\uffb8\010\uffb8\011\uffb8\013\uffb8\024\uffb8\031" +
    "\uffb8\064\uffb8\001\002\000\010\003\341\024\120\035\uffbd" +
    "\001\002\000\004\035\343\001\002\000\004\035\342\001" +
    "\002\000\024\005\uffb7\006\uffb7\007\uffb7\010\uffb7\011\uffb7" +
    "\013\uffb7\024\uffb7\031\uffb7\064\uffb7\001\002\000\024\005" +
    "\uffba\006\uffba\007\uffba\010\uffba\011\uffba\013\uffba\024\uffba" +
    "\031\uffba\064\uffba\001\002\000\026\005\131\006\136\007" +
    "\133\010\116\011\134\013\125\024\120\031\117\032\345" +
    "\064\121\001\002\000\030\005\uffa5\006\uffa5\007\uffa5\010" +
    "\uffa5\011\uffa5\013\uffa5\014\uffa5\024\uffa5\031\uffa5\032\uffa5" +
    "\064\uffa5\001\002\000\004\024\120\001\002\000\010\035" +
    "\350\036\202\042\203\001\002\000\004\033\351\001\002" +
    "\000\030\005\uffac\006\uffac\007\uffac\010\uffac\011\uffac\013" +
    "\uffac\014\uffac\024\uffac\031\uffac\032\uffac\064\uffac\001\002" +
    "\000\004\024\014\001\002\000\006\035\uffc8\040\uffc8\001" +
    "\002\000\004\024\014\001\002\000\006\035\uffc7\040\uffc7" +
    "\001\002\000\010\035\uffc5\036\357\040\uffc5\001\002\000" +
    "\004\037\360\001\002\000\006\035\uffc4\040\uffc4\001\002" +
    "\000\004\034\uffd3\001\002\000\004\034\363\001\002\000" +
    "\010\003\105\024\014\035\uffca\001\002\000\004\035\365" +
    "\001\002\000\006\024\uffde\031\uffde\001\002\000\006\024" +
    "\014\031\367\001\002\000\026\005\uffd2\006\uffd2\007\uffd2" +
    "\010\uffd2\011\uffd2\013\uffd2\024\uffd2\031\uffd2\032\uffd2\064" +
    "\uffd2\001\002\000\026\005\uffc1\006\uffc1\007\uffc1\010\uffc1" +
    "\011\uffc1\013\uffc1\024\uffc1\031\uffc1\032\uffc1\064\uffc1\001" +
    "\002\000\026\005\131\006\136\007\133\010\116\011\134" +
    "\013\125\024\120\031\117\032\372\064\121\001\002\000" +
    "\012\012\uffd1\024\uffd1\032\uffd1\063\uffd1\001\002\000\012" +
    "\003\uffe4\024\uffe4\031\uffe4\032\uffe4\001\002\000\012\003" +
    "\uffde\024\uffde\031\uffde\032\uffde\001\002\000\012\003\054" +
    "\024\014\031\051\032\uffe0\001\002\000\004\032\377\001" +
    "\002\000\012\015\uffe3\017\uffe3\024\uffe3\031\uffe3\001\002" +
    "\000\012\003\uffde\024\uffde\031\uffde\032\uffde\001\002\000" +
    "\012\003\054\024\014\031\051\032\uffe0\001\002\000\004" +
    "\032\u0103\001\002\000\012\015\uffe7\017\uffe7\024\uffe7\031" +
    "\uffe7\001\002\000\012\012\uffcc\024\uffcc\032\u0105\063\074" +
    "\001\002\000\004\002\001\001\002\000\004\024\u010c\001" +
    "\002\000\006\033\u0109\040\u0108\001\002\000\012\015\uffed" +
    "\017\uffed\024\uffed\031\uffed\001\002\000\012\015\uffee\017" +
    "\uffee\024\uffee\031\uffee\001\002\000\006\033\u0110\040\u010f" +
    "\001\002\000\006\033\uffeb\040\uffeb\001\002\000\010\033" +
    "\uffea\036\u010d\040\uffea\001\002\000\004\037\u010e\001\002" +
    "\000\006\033\uffe9\040\uffe9\001\002\000\004\024\u010c\001" +
    "\002\000\012\015\uffef\017\uffef\024\uffef\031\uffef\001\002" +
    "\000\006\033\uffec\040\uffec\001\002\000\004\002\000\001" +
    "\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u0110\000\004\004\003\001\001\000\002\001\001\000" +
    "\004\047\006\001\001\000\002\001\001\000\004\003\007" +
    "\001\001\000\014\002\011\007\014\017\015\021\016\062" +
    "\010\001\001\000\004\071\u0105\001\001\000\002\001\001" +
    "\000\004\011\u0103\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\062\021\001\001\000\004\070\024\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\022\025\023\026" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\066\032\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\023" +
    "\037\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\072\041\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\073\045\001\001\000\002\001\001" +
    "\000\004\016\047\001\001\000\010\013\051\020\054\062" +
    "\052\001\001\000\004\011\071\001\001\000\002\001\001" +
    "\000\004\075\057\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\014\060" +
    "\015\061\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\015\067\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\012\075\044\072\001\001\000\004" +
    "\062\076\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\100\101\001\001\000\002\001\001\000\012\024\107\025" +
    "\106\060\105\062\103\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\016\111\001\001\000\006\013\051\062\052" +
    "\001\001\000\004\101\113\001\001\000\004\031\114\001" +
    "\001\000\020\005\127\030\125\035\131\036\121\037\126" +
    "\041\123\050\122\001\001\000\002\001\001\000\004\031" +
    "\343\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\032\300\053\276\056\275\061\277\103" +
    "\304\001\001\000\022\005\127\030\270\035\271\036\121" +
    "\037\126\041\123\042\267\050\122\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\016\005\127" +
    "\035\241\036\240\037\126\041\123\050\122\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\050\142\063\146\064\141\065\150\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\050\142" +
    "\063\226\065\150\001\001\000\004\062\221\001\001\000" +
    "\010\052\161\053\157\054\162\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\055\172\056\165\057\173\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\050\142\063\146\064\152\065" +
    "\150\001\001\000\010\052\161\053\157\054\162\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\104\163\001\001\000\002\001\001\000\010\050\142\063" +
    "\164\065\150\001\001\000\010\055\172\056\165\057\173" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\105\176" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\050\142\065\177\001\001\000\002\001\001" +
    "\000\016\026\211\027\214\050\142\063\146\064\212\065" +
    "\150\001\001\000\004\106\205\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\050\142\063" +
    "\146\064\206\065\150\001\001\000\010\052\161\053\157" +
    "\054\162\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\052\161\053\157\054\162\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\050\142\063" +
    "\146\064\216\065\150\001\001\000\010\052\161\053\157" +
    "\054\162\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\043\222\001\001\000\002\001\001\000\012\050\142" +
    "\063\146\064\224\065\150\001\001\000\010\052\161\053" +
    "\157\054\162\001\001\000\002\001\001\000\010\055\172" +
    "\056\165\057\173\001\001\000\002\001\001\000\012\050" +
    "\142\063\146\064\231\065\150\001\001\000\010\052\161" +
    "\053\157\054\162\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\020\033\245\034\250\050\142\063\146" +
    "\064\244\065\150\067\246\001\001\000\012\051\261\052" +
    "\161\053\157\054\162\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\050" +
    "\142\063\146\064\244\065\150\067\252\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\016\034" +
    "\256\050\142\063\146\064\244\065\150\067\246\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\050\142\063\146\064\266\065\150\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\052\161\053\157\054\162\001\001\000\016" +
    "\005\127\035\274\036\273\037\126\041\123\050\122\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\102\312\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\016\026\306\027\214\050\142\063\146" +
    "\064\212\065\150\001\001\000\002\001\001\000\004\040" +
    "\311\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\050\142\063\146\064\314\065\150\001\001\000\002\001" +
    "\001\000\010\052\161\053\157\054\162\001\001\000\010" +
    "\037\320\046\316\050\122\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\022" +
    "\033\323\034\250\045\324\050\142\063\146\064\244\065" +
    "\150\067\246\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\037\320\046\326\050\122\001\001\000\002\001" +
    "\001\000\002\001\001\000\022\033\323\034\250\045\331" +
    "\050\142\063\146\064\244\065\150\067\246\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\037\320\046\334" +
    "\050\122\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\037\320\046\337\050\122\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\005\127\030\125\035\131\036\121\037\126\041\123" +
    "\050\122\001\001\000\002\001\001\000\004\050\346\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\024\352\062\103\001\001\000\002\001\001\000" +
    "\006\024\354\062\103\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\076" +
    "\361\001\001\000\002\001\001\000\012\024\107\025\363" +
    "\060\105\062\103\001\001\000\002\001\001\000\004\016" +
    "\365\001\001\000\006\013\051\062\052\001\001\000\004" +
    "\077\367\001\001\000\004\031\370\001\001\000\020\005" +
    "\127\030\125\035\131\036\121\037\126\041\123\050\122" +
    "\001\001\000\002\001\001\000\004\074\373\001\001\000" +
    "\004\016\374\001\001\000\010\013\051\020\375\062\052" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\016" +
    "\u0100\001\001\000\010\013\051\020\u0101\062\052\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\012\075\044" +
    "\072\001\001\000\002\001\001\000\006\006\u0109\010\u010a" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\010\u0110\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	Tab.init(); // Universe scope
	stringType = new Struct(Struct.Array, Tab.charType);
    boolType = new Struct(Struct.Bool);
    Tab.currentScope().addToLocals(new Obj(Obj.Type, "bool", boolType));
	stackPeak = Tab.insert(Obj.Var, "", Tab.intType);
	
    Obj func = Tab.find("chr");
    for (Obj obj : func.getLocalSymbols())
		obj.setFpPos(1);
    func = Tab.find("ord");
    for (Obj obj : func.getLocalSymbols())
		obj.setFpPos(1);
    func = Tab.find("len");
    for (Obj obj : func.getLocalSymbols())
		obj.setFpPos(1);

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;

    }


	
	
// *** Sekcija promenljivih za prebrojavanje

	// A
	int globalVarCnt = 0; // globalne varijable
	int localVarInMainCnt = 0; // definicije lokalnih varijabli u "main"
	int globalConstCnt = 0; // globalne konstante
	int globalArrayVarCnt = 0;	// globalni nizovi

	// B
	int progFuncCnt = 0; // definicije globalnih i statickih funkcija
	int blockCnt = 0; // blokovi naredbi
	int funcCallInMainCnt = 0; // pozivi funkcija u telu metode main
	int formArgsCnt = 0; // formalni argumenti funkcija

	// C
	int classCnt = 0; // definicije klasa
	int classMethodCnt = 0; // broj metoda unutar klase 
	int classFieldCnt = 0; // deklaracija polja klase

	
// *** Tipovi
	
	Struct stringType;
	Struct boolType;	
	
	
	boolean errorDetected = false;
	Logger log = Logger.getLogger(getClass());
   	Obj stackPeak = null; // vrh steka
	
	
   
// *** Redefinisane metode za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
    } 
  
    public void syntax_error(Symbol cur_token) {
		report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
		System.err.println(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


	int EQUAL_VALUE = 1000;
	Obj lastArrayAddr = null;
	Obj lastArrayInd = new Obj(Obj.Var, "", Tab.intType);
	Stack<Obj> lastFactorDesignatorStack = new Stack<>();
	Obj lastFactorDesignator = null;

	Struct varType = Tab.noType;
	Struct constType = Tab.noType;
	Obj currentMethod = null;
	Obj currentClass = null;
	Obj calledMethod = null;
	String methN = null;
	int methNleft;
	boolean isVoid = false;	
	
	boolean mainDeclared = false;
	boolean returnFound = false;
	boolean classDeclared = false;
	boolean methodDeclared = false;
	boolean insideFor = false;
	int currentScope = -1;
	
	int tempConstInt = 0;
	
	int adr;
	int adrIf[] = new int[1000];
	int adrIf2[] = new int[1000];
	int rel;
	int top;
	int breakAdr;
	
	int ifLvl = 0;
	
	boolean breakExists = false;
	boolean complexRel  = false;
	
	ArrayList<Struct> actualParams = new ArrayList<Struct>();	
	
	private boolean checkFunctionParamTypes(int funcleft, Obj func) {
		boolean result = true;
		ArrayList<Struct> formalParams = new ArrayList<Struct>();
		for (Obj obj : func.getLocalSymbols()) {
			if (obj.getFpPos() > 0)
				formalParams.add(obj.getType());
		}
		
		if (formalParams.size() != actualParams.size()) {
			parser.report_error("Greska na liniji " + funcleft + " : broj formalnih i stvarnih argumenata funkcije " + func.getName() + " se ne poklapa!", null);
			result = false;
		}
		else {
			for (int i = 0; i < formalParams.size(); i++) {
				if (!actualParams.get(i).assignableTo(formalParams.get(i))) {
					parser.report_error("Greska na liniji " + funcleft + " : tip " + (i+1) + ". stvarnog argumenta funkcije " + func.getName() + " se ne poklapa sa formalnim!", null);
					result = false;
				}										
			}
		}
		return result;
	}

	String visit(Obj sym) {
		DumpSymbolTableVisitor visitor = new DumpSymbolTableVisitor();
		visitor.visitObjNode(sym);
		return visitor.getOutput();
	}

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // MulopRight ::= MODUO_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.rem + EQUAL_VALUE; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // MulopRight ::= DIV_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.div + EQUAL_VALUE; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // MulopRight ::= MUL_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.mul + EQUAL_VALUE; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // MulopLeft ::= MODUO 
            {
              Integer RESULT =null;
		 RESULT = Code.rem; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // MulopLeft ::= DIV 
            {
              Integer RESULT =null;
		 RESULT = Code.div; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // MulopLeft ::= MUL 
            {
              Integer RESULT =null;
		 RESULT = Code.mul; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // Mulop ::= MulopLeft 
            {
              Integer RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer l = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = l; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // Mulop ::= MulopRight 
            {
              Integer RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer r = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = r; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // AddopRight ::= MINUS_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.sub + EQUAL_VALUE; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopRight",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // AddopRight ::= PLUS_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.add + EQUAL_VALUE; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopRight",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // AddopLeft ::= MINUS 
            {
              Integer RESULT =null;
		 RESULT = Code.sub; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopLeft",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // AddopLeft ::= PLUS 
            {
              Integer RESULT =null;
		 RESULT = Code.add; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopLeft",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // Addop ::= AddopLeft 
            {
              Integer RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer l = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = l; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // Addop ::= AddopRight 
            {
              Integer RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer r = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = r; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // Relop ::= LESS_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = rel = 3; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // Relop ::= LESS 
            {
              Integer RESULT =null;
		 RESULT = rel = 2; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Relop ::= GREATER_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = rel = 5; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Relop ::= GREATER 
            {
              Integer RESULT =null;
		 RESULT = rel = 4; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Relop ::= NOT_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = rel = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // Relop ::= IS_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = rel = 0; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // Assignop ::= MulopRight 
            {
              Integer RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer m = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = m; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // Assignop ::= AddopRight 
            {
              Integer RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer a = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = a; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // Assignop ::= EQUAL 
            {
              Integer RESULT =null;
		 RESULT = EQUAL_VALUE; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // Designator ::= IDENT 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   		Obj obj = Tab.find(name);
			   		if (obj == Tab.noObj) {
			   			parser.report_error("Greska na liniji " + nameleft + " : ime " + name + " nije deklarisano! ", null);
			   		}
			   		else {
			   			parser.report_info("Na liniji " + nameleft + " detektovano koriscenje simbola: " + visit(obj), null);
			   		}
			   		RESULT = obj;	   
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // Designator ::= Designator DOT IDENT 
            {
              Obj RESULT =null;
		int desleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj des = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   	Obj temp = des.getType().getMembersTable().searchKey(i);
			   	if (des.getType().getKind() != Struct.Class) {
			   		parser.report_error("Greska na liniji " + desleft + " : " + des.getName() + " nije klasa ", null);
					RESULT = des;
			   	}
			   	else if (temp == null) {
			   		parser.report_error("Greska na liniji " + desleft + " : " + i + " nije clan klase ", null);
			   		RESULT = des;
			   	}
			   	else
			   		parser.report_info("Na liniji " + ileft + " detektovano koriscenje simbola: " + visit(temp), null);
			   		RESULT = temp;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // Designator ::= Designator LBRACKET error RBRACKET 
            {
              Obj RESULT =null;
		int desleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int desright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj des = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 
				parser.report_info("Uspesan oporavak od greske pri indeksiranju niza do ] na liniji " + desleft, null);
			   	
			   	Obj obj  = Tab.find(des.getName());
			   	if (des.getType().getKind() != Struct.Array)
			   		parser.report_error("Greska na liniji " + desleft + " : " + des.getName() + " nije niz ", null);
			   	RESULT = obj;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // Designator ::= Designator LBRACKET NT$14 Expr RBRACKET 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int desleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int desright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj des = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			   	if (e.getKind() != Struct.Int)
			   		parser.report_error("Greska na liniji " + desleft + " : " + " izraz mora biti tipa int! ", null); // za indeksiranje niza ne sme izraz
				else {
					Code.store(lastArrayInd);
					Code.load(lastArrayInd);
				}
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // NT$14 ::= 
            {
              Obj RESULT =null;
		int desleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int desright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj des = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

			   	Obj obj  = Tab.find(des.getName());
			   	if (des.getType().getKind() != Struct.Array)
			   		parser.report_error("Greska na liniji " + desleft + " : " + des.getName() + " nije niz ", null);
			   	if (des.getType().getKind() == Struct.Array) {
			   		Code.load(des);
					lastArrayAddr = des;
			   		RESULT = new Obj(Obj.Elem, "", des.getType().getElemType());
			   		parser.report_info("Na liniji " + desleft + " detektovano koriscenje clana niza " + visit(des), null);
			   	}
			   	else 
			   		RESULT = Tab.noObj;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$14",68, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // FactExpr ::= 
            {
              Boolean RESULT =null;
		
			 	RESULT = false;
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FactExpr",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // FactExpr ::= LBRACKET Expr RBRACKET 
            {
              Boolean RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			 	if (t.getKind() != Struct.Int)
			 		parser.report_error("Greska na liniji " + tleft + " : izraz mora biti tipa int.", null);
			 	RESULT = true;
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FactExpr",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Factor ::= Designator LPAREN ActualPars RPAREN 
            {
              Struct RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
				if (!func.equals(Tab.noObj)) {
					if (Obj.Meth == func.getKind()) {
						if (currentMethod.getName().equals("main"))
							this.parser.funcCallInMainCnt++;
						parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
						if (func.getType() == Tab.noType) {
							parser.report_error("Greska na liniji " + funcleft + " : " + func.getName() + " ne moze se koristiti u izrazima jer nema povratnu vrednost", null);
						}
						else {
							ArrayList<Struct> formalParams = new ArrayList<Struct>();
						
							if (checkFunctionParamTypes(funcleft, func)) {
								int destAdr = func.getAdr() - Code.pc;
								Code.put(Code.call);
								Code.put2(destAdr);
							}
						}
						RESULT = func.getType();
					}else {
						parser.report_error("Greska na liniji " + funcleft + " : ime " + func.getName() + " nije funkcija!", null);
						RESULT = Tab.noType;
					}
				} else {
					RESULT = Tab.noType;
				}
				actualParams.clear();
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // Factor ::= Designator 
            {
              Struct RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		   	RESULT = d.getType(); 
		   	Code.load(d);
			lastFactorDesignator = d;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // Factor ::= NEW Type FactExpr 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			   if (b) {
					Code.put(Code.newarray);
					if (t.equals(Tab.charType))
						Code.put(0);
					else
						Code.put(1);
					RESULT = new Struct(Struct.Array, t);
			   }
			   else					
					RESULT = t;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // Factor ::= BOOL_CONST 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean i = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		   	Obj c = Tab.insert(Obj.Con, "", parser.boolType);
		   	c.setAdr(i ? 1 : 0);
		   	Code.load(c);
		   	RESULT = parser.boolType; 
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // Factor ::= LPAREN Expr RPAREN 
            {
              Struct RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 RESULT = e;  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // Factor ::= CHAR_CONST 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character i = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		   	Obj c = Tab.insert(Obj.Con, "", Tab.nullType);
		   	c.setAdr(i.charValue());
		   	Code.load(c);
		   	RESULT = Tab.charType; 
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // Factor ::= NUM_CONST 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		   	Obj c = Tab.insert(Obj.Con, "", Tab.intType);
		   	c.setAdr(i.intValue());
		   	Code.load(c);
		   	RESULT = Tab.intType;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // Term ::= Factor 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		 	RESULT = t;
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // Term ::= Term Mulop NT$13 Factor 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct f = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			if (!Tab.intType.equals(t) || !Tab.intType.equals(f)) {
		 		parser.report_error("Greska na liniji " + tleft + " : izrazi moraju biti tipa int.", null);
		 		RESULT = Tab.noType;
		 	}
		 	else {
		 		Code.put(op > EQUAL_VALUE ? op - EQUAL_VALUE : op);
				if (op > EQUAL_VALUE) {
					Obj dest = lastFactorDesignatorStack.pop();
					Obj temp = new Obj(Obj.Var, "", Tab.intType);
					Code.store(temp);
					Code.load(temp);
					Code.store(dest);
					Code.load(temp);
				}
		 		RESULT = t;
		 	}
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // NT$13 ::= 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

			if (op > EQUAL_VALUE) {
				if (lastFactorDesignator.getKind() == Obj.Elem) {
					Code.store(parser.stackPeak);
					Code.load(lastArrayAddr);
					Code.load(lastArrayInd);
					Code.load(parser.stackPeak);
				}
				lastFactorDesignatorStack.push(lastFactorDesignator);
			}
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$13",67, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // Expr ::= MINUS Term 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		 	if (!t.equals(Tab.intType)) { 
		 		parser.report_error("Greska na liniji " + tleft + " : izraz mora biti tipa int.", null); // negativna vrednost samo za tip int
		 		RESULT = Tab.noType;
			}
			else {
				Code.put(Code.neg);
		 		RESULT = t;
		 	} 
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // Expr ::= Term 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // Expr ::= Expr Addop NT$12 Term 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int teleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int teright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct te = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		 	if (te.equals(t) && (te == Tab.intType || te == parser.stringType)) {
		 		RESULT = te;
		 		Code.put(op > EQUAL_VALUE ? op - EQUAL_VALUE : op);
				if (op > EQUAL_VALUE) {
					Obj dest = lastFactorDesignatorStack.pop();
					Obj temp = new Obj(Obj.Var, "", Tab.intType);
					Code.store(temp);
					Code.load(temp);
					Code.store(dest);
					Code.load(temp);
				}
		 	}
		 	else {
		 		parser.report_error("Greska na liniji " + teleft + " : nekompatibilni tipovi u izrazu za sabiranje.", null);
		 		RESULT = te;
		 	}
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // NT$12 ::= 
            {
              Struct RESULT =null;
		int teleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int teright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct te = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

			if (op > EQUAL_VALUE) {
				if (lastFactorDesignator.getKind() == Obj.Elem) {
					Code.store(parser.stackPeak);
					Code.load(lastArrayAddr);
					Code.load(lastArrayInd);
					Code.load(parser.stackPeak);
				}
				lastFactorDesignatorStack.push(lastFactorDesignator);
			}
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$12",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // CondFact ::= Expr 
            {
              Struct RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 	RESULT = expr;
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // CondFact ::= Expr Relop Expr 
            {
              Struct RESULT =null;
		int expr0left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int expr0right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct expr0 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			 	complexRel = true;
			 	if (expr0.assignableTo(expr)) {
					if (op > 1 && (expr0.getKind() == Struct.Class || expr0.equals(parser.stringType))) { // uslov za poredjenje klasa i stringova
						parser.report_error("Greska na liniji " + exprleft + " : Stringovi i klase se mogu porediti samo sa == ili !=.", null);
						RESULT = Tab.noType;
					}
					else	
						RESULT = expr0;
			 	}
			 	else {
			 		parser.report_error("Greska na liniji " + exprleft + " : Nekompatibilni tipovi u uslovnom izrazu.", null);
		 			RESULT = Tab.noType;
			 	}
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // CondTerm ::= CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // CondTerm ::= CondTerm AND CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // Condition ::= CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // Condition ::= Condition OR CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // ActualParamList ::= Expr 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
						actualParams.add(e);
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualParamList",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // ActualParamList ::= ActualParamList COMMA Expr 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
						actualParams.add(e);
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualParamList",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // ActualPars ::= error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.report_info("Uspesan oporavak od greske do ) prilikom deklarisanja stvarnih argumenata tj. liste parametara funkcije na liniji " + eleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualPars",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // ActualPars ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualPars",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // ActualPars ::= ActualParamList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualPars",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // StatementOpt ::= MINUS_MINUS 
            {
              Object RESULT =null;
		 
				 	Obj c = Tab.insert(Obj.Con, "", Tab.intType);
		   			c.setAdr(-1);
		   			Code.load(c);
				 	RESULT = Code.add;
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementOpt",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // StatementOpt ::= PLUS_PLUS 
            {
              Object RESULT =null;
		 
		   			Obj c = Tab.insert(Obj.Con, "", Tab.intType);
		   			c.setAdr(1);
		   			Code.load(c);
		   			RESULT = Code.add;
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementOpt",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // FuncOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FuncOpt",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // FuncOpt ::= error 
            {
              Object RESULT =null;
		 parser.log.debug("Uspesan oporavak od greske pri pozivu funkcije."); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FuncOpt",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // DesignatorStatement ::= Designator StatementOpt 
            {
              Object RESULT =null;
		int desleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int desright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj des = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int optleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int optright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object opt = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							if (des.getType().getKind() != Struct.Int) {
								parser.report_error("Greska na liniji " + desleft + " : " + " lvrednost mora biti tipa int ", null);
							}
							else {
								Code.load(des);	
								Code.put((Integer)opt);
								Code.store(des);
							}
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // DesignatorStatement ::= Designator NT$11 LPAREN ActualPars RPAREN FuncOpt 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		
							if (!func.equals(Tab.noObj)) {
								if (Obj.Meth == func.getKind()) {
									if (currentMethod.getName().equals("main"))
										this.parser.funcCallInMainCnt++;
									parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
									RESULT = func.getType();
									
									if (checkFunctionParamTypes(funcleft, func)) {
										int destAdr = func.getAdr() - Code.pc;
										Code.put(Code.call);
										Code.put2(destAdr);
										if (func.getType() != Tab.noType) {
											Code.put(Code.pop);
										}
									}
									
								}
								else {
									parser.report_error("Greska na liniji " + funcleft + " : ime " + func.getName() + " nije funkcija!", null);
									RESULT = Tab.noType;
								}
							}
							calledMethod = null;
							actualParams.clear();
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // NT$11 ::= 
            {
              Object RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 calledMethod = func; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$11",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // DesignatorStatement ::= Designator Assignop error 
            {
              Object RESULT =null;
		 parser.log.debug("Uspesan oporavak od greske do ; pri dodeli vrednosti."); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // DesignatorStatement ::= Designator Assignop NT$10 Expr 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int destleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int destright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj dest = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							if (!Tab.noType.equals(e)) {
								boolean ind = true;
								if (dest.getType().getElemType() == null) {
									if (e.getElemType() != null || !e.assignableTo(dest.getType())) {
										parser.report_error("Greska na liniji " + destleft + " : " + " nekompatibilni tipovi u dodeli vrednosti ", null);
										ind = false;
									}
								}
								else {
									if (!e.assignableTo(dest.getType())) {
										parser.report_error("Greska na liniji " + destleft + " : " + " nekompatibilni tipovi u dodeli vrednosti ", null);
										ind = false;
									}
								}
								if (dest.getKind() != Obj.Var && dest.getKind() != Obj.Elem && dest.getKind() != Obj.Fld) {
										parser.report_error("Greska na liniji " + destleft + " : promenljiva " + dest.getName() + " mora biti promenljiva, element niza ili polje klase! ", null);
										ind = false;
								}
								if (ind == true) {
									if (op > EQUAL_VALUE) {
										Code.put(op - EQUAL_VALUE);
									}
									Code.store(dest);
								}
							}
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // NT$10 ::= 
            {
              Object RESULT =null;
		int destleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int destright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj dest = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

							if (op > EQUAL_VALUE) {
								if (dest.getKind() == Obj.Elem) {
									Code.load(lastArrayAddr);
									Code.load(lastArrayInd);
								}
								Code.load(dest);
							}
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$10",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // Matched ::= LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
		 this.parser.blockCnt++; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // Matched ::= RETURN SEMI 
            {
              Object RESULT =null;
		int blaleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int blaright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object bla = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				Struct currMethType = currentMethod.getType();
				if (!currMethType.compatibleWith(Tab.noType)) {
					parser.report_error("Greska na liniji "+blaleft+ " : " + "tip izraza u return naredbi se mora deklarisati", null);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // Matched ::= RETURN Expr SEMI 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				returnFound = true;
				Struct currMethType = currentMethod.getType();
				if (!currMethType.compatibleWith(t)) {
					parser.report_error("Greska na liniji "+tleft+ " : " + "tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije " + currentMethod.getName(), null);
				}
				else {
					Code.put(Code.exit);
					Code.put(Code.return_);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // Matched ::= CONTINUE SEMI 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				if (!insideFor) {
					parser.report_error("Greska na liniji " + bleft + " : zabranjeno koriscenje continue van for petlje!", null);
				}
				else {
					breakAdr = Code.pc + 1;
					breakExists = true;
					Code.putJump(0);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // Matched ::= BREAK SEMI 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				if (!insideFor) {
					parser.report_error("Greska na liniji " + bleft + " : zabranjeno koriscenje break-a van for petlje!", null);
				}
				else {
					breakAdr = Code.pc + 1;
					breakExists = true;
					Code.putJump(0);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // Matched ::= PRINT LPAREN Expr COMMA NUM_CONST RPAREN SEMI 
            {
              Object RESULT =null;
		int desleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int desright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct des = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
				if (currentMethod.getName().equals("main"))
					this.parser.funcCallInMainCnt++;
				if (!(des == Tab.intType || des == Tab.charType
				    || des == parser.boolType || des == parser.stringType)) {
				    	parser.report_error("Greska na liniji " + desleft + " : izraz nije tipa int, char ili bool", null);
				    }
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // Matched ::= PRINT LPAREN Expr RPAREN SEMI 
            {
              Object RESULT =null;
		int desleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct des = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if (currentMethod.getName().equals("main"))
					this.parser.funcCallInMainCnt++;
				if (!(des == Tab.intType || des == Tab.charType
				    || des == parser.boolType || des == parser.stringType)) {
				    	parser.report_error("Greska na liniji " + desleft + " : izraz nije tipa int, char ili bool", null);
				    }				
				if (des == Tab.intType) {
					Code.loadConst(5);
					Code.put(Code.print);	
				}
				
				if (des == Tab.charType) {
					Code.loadConst(1);
					Code.put(Code.bprint);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // Matched ::= READ LPAREN Designator RPAREN SEMI 
            {
              Object RESULT =null;
		int desleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int desright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj des = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
				if (currentMethod.getName().equals("main"))
					this.parser.funcCallInMainCnt++;
				boolean ind = true;
				if (!(des.getType() == Tab.intType || des.getType() == Tab.charType
				    || des.getType() == parser.boolType || des.getType() == parser.stringType)) {
				    	parser.report_error("Greska na liniji " + desleft + " : izraz nije tipa int, char ili bool", null);
				    	ind = false;
				    }
				if (des.getKind() != Obj.Var && des.getKind() != Obj.Elem && des.getKind() != Obj.Fld) {
			   			parser.report_error("Greska na liniji " + desleft + " : identifikator " + des.getName() + " mora biti promenljiva, element niza ili polje klase! ", null);
			   			ind = false;
			   	}
				if (ind == true) {
					Code.put(Code.read);
					Code.store(des);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // Matched ::= ForPart Matched 
            {
              Object RESULT =null;
		
				Code.putJump((Integer)top);
				Code.fixup(adr);
				if (breakExists) {
					Code.fixup(breakAdr);
				}
				breakExists = false;
				insideFor = false;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // Matched ::= Iffirst Ifsecond Matched 
            {
              Object RESULT =null;
		 Code.fixup(adrIf2[ifLvl]); ifLvl--; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // Matched ::= DesignatorStatement SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // Ifsecond ::= Matched ELSE 
            {
              Object RESULT =null;
		 Code.putJump(0); adrIf2[ifLvl] = Code.pc - 2; Code.fixup(adrIf[ifLvl]); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Ifsecond",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // Iffirst ::= IF LPAREN error RPAREN 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 parser.report_info("Uspesan oporavak od greske do ) u uslovu na liniji " + eleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Iffirst",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // Iffirst ::= IF LPAREN Condition RPAREN 
            {
              Object RESULT =null;
		 
				if (complexRel == false) {
			 		Obj c = Tab.insert(Obj.Con, "", Tab.intType);
				   	c.setAdr(0);
				   	Code.load(c);
				   	rel = 1;
			 	}
			 	complexRel = false;
				ifLvl++; Code.putFalseJump(rel, 0); adrIf[ifLvl] = Code.pc - 2; 
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Iffirst",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // Unmatched ::= ForPart Unmatched 
            {
              Object RESULT =null;
		
					Code.putJump((Integer)top);
					Code.fixup(adr);
					if (breakExists) {
						Code.fixup(breakAdr);
					}
					breakExists = false;
					insideFor = false;
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // Unmatched ::= Iffirst Ifsecond Unmatched 
            {
              Object RESULT =null;
		 Code.fixup(adrIf2[ifLvl]); ifLvl--; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // Unmatched ::= Iffirst Statement 
            {
              Object RESULT =null;
		 Code.fixup(adrIf[ifLvl]); ifLvl--; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // ForPart ::= FOR LPAREN error RPAREN 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				insideFor = true;
				 parser.report_info("Uspesan oporavak od greske do ) unutar FOR-a na liniji " + eleft, null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForPart",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // ForPart ::= FOR LPAREN OptDesignatorStatement SEMI OptCondition SEMI error RPAREN 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				insideFor = true;
				 parser.report_info("Uspesan oporavak od greske do ) unutar FOR-a na liniji " + eleft, null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForPart",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // ForPart ::= FOR LPAREN OptDesignatorStatement SEMI error SEMI OptDesignatorStatement RPAREN 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
				insideFor = true;
				 parser.report_info("Uspesan oporavak od greske do ; unutar FOR-a na liniji " + eleft, null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForPart",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // ForPart ::= FOR LPAREN error SEMI OptCondition SEMI OptDesignatorStatement RPAREN 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		
				insideFor = true;
				 parser.report_info("Uspesan oporavak od greske do ; unutar FOR-a na liniji " + eleft, null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForPart",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // ForPart ::= FOR LPAREN OptDesignatorStatement SEMI OptCondition SEMI OptDesignatorStatement RPAREN 
            {
              Object RESULT =null;
		 insideFor = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ForPart",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // OptCondition ::= 
            {
              Boolean RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptCondition",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // OptCondition ::= Condition 
            {
              Boolean RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptCondition",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // OptDesignatorStatement ::= 
            {
              Boolean RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptDesignatorStatement",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // OptDesignatorStatement ::= DesignatorStatement 
            {
              Boolean RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptDesignatorStatement",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Statement ::= Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Statement ::= Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String typeName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
		Obj typeNode = Tab.find(typeName);
		if (typeNode == Tab.noObj) {
			parser.report_error("Greska na liniji " + typeNameleft +" : nije pronadjen tip " + typeName + " u tabeli simbola", null);
			RESULT = Tab.noType;
		}
		else {
			if (Obj.Type == typeNode.getKind()) {
				RESULT = typeNode.getType();
			   	parser.report_info("Na liniji " + typeNameleft + " detektovano koriscenje tipa " + visit(typeNode), null);
			}
			else {
				parser.report_error("Greska na liniji" + typeNameleft + ": Ime " + typeName + " ne predstavlja tip", null);
				RESULT = Tab.noType;
			}
		}
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // FormalParamDecl ::= Type IDENT LBRACKET RBRACKET 
            {
              Object RESULT =null;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
						Obj temp = Tab.currentScope().findSymbol(varName);
						if (temp != null) {
							parser.report_error("Greska na liniji " + varNameleft + ": Niz " + varName + " je vec deklarisana", null);
						}
						else {
							parser.report_info("Deklarisan niz " + varName + " na liniji " + varNameleft, null);
							Obj param = Tab.insert(Obj.Var, varName, new Struct(Struct.Array, varType)); 
							param.setFpPos(1);
						}
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FormalParamDecl ::= Type IDENT 
            {
              Object RESULT =null;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
						Obj temp = Tab.currentScope().findSymbol(varName);
						if (temp != null) {
							parser.report_error("Greska na liniji " + varNameleft + ": Lokalna promenljiva " + varName + " je vec deklarisana", null);
						}
						else {
							parser.report_info("Deklarisana formalna promenljiva " + varName + " na liniji " + varNameleft, null);
							Obj param = Tab.insert(Obj.Var, varName, varType);
							param.setFpPos(1);
						}
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // FormalParamList ::= FormalParamDecl 
            {
              Integer RESULT =null;
		 RESULT = new Integer(1); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // FormalParamList ::= error COMMA FormalParamDecl 
            {
              Integer RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
						parser.report_info("Uspesan oporavak od greske do , prilikom deklarisanja formalnih argumenata funkcije na liniji " + eleft, null);
						RESULT = 0;
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // FormalParamList ::= FormalParamList COMMA FormalParamDecl 
            {
              Integer RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 RESULT = new Integer(((Integer)n).intValue() + 1); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // FormPars ::= error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				parser.report_info("Uspesan oporavak od greske do ) prilikom deklarisanja formalnih argumenata funkcije na liniji " + eleft, null);
				RESULT = new Integer(0);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // FormPars ::= 
            {
              Object RESULT =null;
		 RESULT = new Integer(0); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // FormPars ::= FormalParamList 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = n; this.parser.formArgsCnt += n; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // OptStatic ::= 
            {
              Boolean RESULT =null;
		 RESULT = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptStatic",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // OptStatic ::= STATIC 
            {
              Boolean RESULT =null;
		 RESULT = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OptStatic",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // MethodDecl ::= OptStatic VOID IDENT NT$8 LPAREN FormPars RPAREN LocalVarList LBRACE NT$9 StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int statleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).left;
		int statright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).right;
		Boolean stat = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).value;
		int methNleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int methNright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		String methN = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		
			   		this.parser.blockCnt++;
			   		
			   		Code.put(Code.exit);
			   		Code.put(Code.return_);
					
					Tab.chainLocalSymbols(currentMethod);
					Tab.closeScope();
			   		
			   		returnFound = false;
			   		currentMethod = null;
			   		currentScope--;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // NT$9 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int statleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int statright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Boolean stat = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int methNleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int methNright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String methN = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
 
					if (currentMethod != null) {
						Tab.chainLocalSymbols(currentMethod);
						currentMethod.setAdr(Code.pc);
						if ("main".equals(methN)) {
							Code.mainPc = currentMethod.getAdr();
						}
						currentMethod.setLevel(((Integer)n));
						Code.put(Code.enter);
						Code.put(currentMethod.getLevel());
						Code.put(Tab.currentScope().getnVars());
			   		}
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$9",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // NT$8 ::= 
            {
              Object RESULT =null;
		int statleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int statright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Boolean stat = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int methNleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methN = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

					if (currentClass != null && !stat)
						this.parser.classMethodCnt++;
					else
						this.parser.progFuncCnt++;
					Obj temp = Tab.currentScope().findSymbol(methN);
					if (temp != null) {
						parser.report_error("Greska na liniji " + methNleft + ": Funkcija " + methN + " je vec deklarisana", null);
						currentMethod = Tab.insert(Obj.Meth, methN + Math.random(), Tab.noType);
						methodDeclared = true;
					}
					else {	
						methodDeclared = false;
						currentMethod = Tab.insert(Obj.Meth, methN, Tab.noType);
						if (methN.equals("main")) {
							mainDeclared = true;
						}
						isVoid = true;
						parser.report_info("Obradjuje se funkcija " + methN + " na liniji " + methNleft, null);
					}
					Tab.openScope();
					currentScope++;					
				/*	if (currentClass != null && !stat) 
						Tab.insert(Obj.Var, "this", currentClass.getType());*/
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$8",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // MethodDecl ::= OptStatic Type IDENT NT$6 LPAREN FormPars RPAREN LocalVarList LBRACE NT$7 StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int statleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).left;
		int statright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).right;
		Boolean stat = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).value;
		int methNleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int methNright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		String methN = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			   		this.parser.blockCnt++;
			   		if (!returnFound && retType != Tab.noType && !methN.equals("main"))
			   			parser.report_error("Semanticka greska na liniji "+rleft+ " : funkcija " +methN + " nema return iskaz!", null);
			   		
			   		if (retType == Tab.noType) {
				   		Code.put(Code.exit);
				   		Code.put(Code.return_);
				   	}
				   	else {
				   		Code.put(Code.trap);
				   		Code.put(1);
				   	}
			   		
					Tab.chainLocalSymbols(currentMethod);
					Tab.closeScope();
			   		
			   		returnFound = false;
			   		currentMethod = null;
			   		currentScope--;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // NT$7 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int statleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int statright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Boolean stat = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int methNleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int methNright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String methN = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
 if (currentMethod != null) Tab.chainLocalSymbols(currentMethod); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$7",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // NT$6 ::= 
            {
              Object RESULT =null;
		int statleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int statright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Boolean stat = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methNleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methN = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
					if (currentClass != null && !stat)
						this.parser.classMethodCnt++;
					else
						this.parser.progFuncCnt++;
					if (methN.equals("main")) {
						mainDeclared = true;
						parser.report_error("Semanticka greska na liniji "+methNleft+ " : funkcija main ne sme imati povratnu vrednost!", null);
					}
					Obj temp = Tab.currentScope().findSymbol(methN);
					if (temp != null) {
						parser.report_error("Greska na liniji " + methNleft + ": Funkcija " + methN + " je vec deklarisana", null);
						currentMethod = Tab.insert(Obj.Meth, methN + Math.random(), retType);
						methodDeclared = true;
					}
					else {
						methodDeclared = false;
						currentMethod = Tab.insert(Obj.Meth, methN, retType);
						if (currentClass != null)
							Tab.chainLocalSymbols(currentClass.getType());
						isVoid = false;
						parser.report_info("Obradjuje se funkcija " + methN + " na liniji " + methNleft, null);
					}
					Tab.openScope();
					currentScope++; // scope za metodu se otvara					
				/*	if (currentClass != null && !stat) 
						Tab.insert(Obj.Var, "this", currentClass.getType());*/
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // MethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // MethodDeclList ::= MethodDeclList MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // LocalVarPart ::= IDENT LBRACKET RBRACKET 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
					Obj temp = Tab.currentScope().findSymbol(varName);
					if (temp != null) {
						parser.report_error("Greska na liniji " + varNameleft + ": Globalna promenljiva " + varName + " je vec deklarisana", null);
					}
					else if (currentClass != null && currentMethod == null) {
				 		this.parser.classFieldCnt++;
				 		parser.report_info("Deklarisana promenljiva " + varName + " na liniji " + varNameleft, null);
						Tab.insert(Obj.Fld, varName, new Struct(Struct.Array, varType));
						Tab.chainLocalSymbols(currentClass.getType());
				 	}
					else {
						parser.report_info("Deklarisana promenljiva " + varName + " na liniji " + varNameleft, null);
						Tab.insert(Obj.Var, varName, new Struct(Struct.Array, varType)); 
					}
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarPart",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // LocalVarPart ::= IDENT 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
					Obj temp = Tab.currentScope().findSymbol(varName);
					if (temp != null) {
						parser.report_error("Greska na liniji " + varNameleft + ": Lokalna promenljiva " + varName + " je vec deklarisana", null);
					}
					else if (currentClass != null && currentMethod == null) {
				 		parser.report_info("Deklarisana promenljiva " + varName + " na liniji " + varNameleft, null);
						Tab.insert(Obj.Fld, varName, varType);
						Tab.chainLocalSymbols(currentClass.getType());
						this.parser.classFieldCnt++;
				 	}
					else {
						parser.report_info("Deklarisana promenljiva " + varName + " na liniji " + varNameleft, null);
						Tab.insert(Obj.Var, varName, varType);
						if (currentMethod.getName().equals("main"))
							this.parser.localVarInMainCnt++;
					}
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarPart",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // LocalVarDeclList ::= LocalVarPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // LocalVarDeclList ::= LocalVarDeclList COMMA LocalVarPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // LocalVarDecl ::= Type error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					if (currentClass != null && currentMethod == null)
						parser.report_info("Uspesan oporavak od greske do { pri deklaraciji polja klase na liniji " + eleft, null);
					else
						parser.report_info("Uspesan oporavak od greske do { pri deklaraciji lokalnih promenljivih na liniji " + eleft, null);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // LocalVarDecl ::= Type error SEMI 
            {
              Object RESULT =null;
		
					if (currentClass != null && currentMethod == null)
						parser.log.debug("Uspesan oporavak od greske do ; pri deklaraciji polja klase.");
					else
						parser.log.debug("Uspesan oporavak od greske do ; pri deklaraciji lokalnih promenljivih.");
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // LocalVarDecl ::= Type NT$5 LocalVarDeclList SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDecl",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // NT$5 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 varType = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // LocalVarList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarList",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // LocalVarList ::= LocalVarList LocalVarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarList",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // ClassMethodList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassMethodList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // ClassMethodList ::= error 
            {
              Object RESULT =null;
		 parser.log.debug("Uspesan oporavak od greske pri deklaraciji metoda unutrasnje klase."); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassMethodList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // ClassMethodList ::= LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassMethodList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // ClassDecl ::= CLASS IDENT EXTENDS error LBRACE NT$4 LocalVarList ClassMethodList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$4 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 
				parser.log.debug("Uspesan oporavak od greske pri deklaraciji prosirenja natklase klase do {.");
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // ClassDecl ::= CLASS IDENT EXTENDS IDENT NT$3 LBRACE LocalVarList ClassMethodList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		 
				Tab.chainLocalSymbols(currentClass.getType());
				Tab.closeScope();
				currentScope--;
				currentClass = null;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$3 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

			  	Obj temp = Tab.find(t);
			  	Obj tmp = Tab.find(className);
			  	if (!tmp.equals(Tab.noObj)) {
			  		parser.report_error("Greska na liniji " + classNameleft + ": Simbol " + className + " je vec deklarisan", null);
					currentClass = Tab.insert(Obj.Type, className + Math.random(), new Struct(Struct.Class));
			  		classDeclared = true;
			  	}
			  	else {
					if (temp.getKind() != Obj.Type)
						parser.report_error("Greska na liniji " + classNameleft + ": Natklasa '" + t + "' nije deklarisana", null);
			  		classDeclared = false;
				  	currentClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
				  	Iterator<Obj> iter = temp.getType().getMembersTable().symbols().iterator();
				  	while(iter.hasNext()) {
				  		Tab.currentScope.addToLocals(iter.next());
				  	}
				  	parser.report_info("Obradjuje se klasa " + className + " na liniji " + classNameleft, null);
			  	}
				Tab.openScope();
				currentScope++; // novi scope za izvedenu klasu
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // ClassDecl ::= CLASS IDENT NT$2 LBRACE LocalVarList ClassMethodList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		 		   	
				Tab.chainLocalSymbols(currentClass.getType()); // lokalni simboli, zbog gazenja imena
				Tab.closeScope();
				currentScope--;
				currentClass = null;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // NT$2 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

			  	Obj temp = Tab.find(className);
			  	if (!temp.equals(Tab.noObj)) {
			  		parser.report_error("Greska na liniji " + classNameleft + ": Simbol " + className + " je vec deklarisan", null);
					currentClass = Tab.insert(Obj.Type, className + Math.random(), new Struct(Struct.Class)); // novo ime u novom scope-u, random jer je jedina, ne moze klasa u klasi
			  		classDeclared = true; // prethodno deklarisana
			  	}
			  	else {
			  		classDeclared = false; // nije prethodno deklarisana
				  	currentClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
				  	parser.report_info("Obradjuje se klasa " + className + " na liniji " + classNameleft, null);
			  	}
				Tab.openScope();
				currentScope++; // novi scope za klasu koja je upravo deklarisana
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // VarPart ::= IDENT LBRACKET RBRACKET 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
				this.parser.globalArrayVarCnt++;
				Obj temp = Tab.currentScope().findSymbol(varName);
				if (temp != null) {
					parser.report_error("Greska na liniji " + varNameleft + ": Niz " + varName + " je vec deklarisan", null);
				}
				else {
					parser.report_info("Deklarisan niz " + varName + " na liniji " + varNameleft, null);
					Tab.insert(Obj.Var, varName, new Struct(Struct.Array, varType)); 
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarPart",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // VarPart ::= IDENT 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				this.parser.globalVarCnt++;
				Obj temp = Tab.currentScope().findSymbol(varName);
				if (temp != null) {
					parser.report_error("Greska na liniji " + varNameleft + ": Globalna promenljiva " + varName + " je vec deklarisana", null);
				}
				else {
					parser.report_info("Deklarisana promenljiva " + varName + " na liniji " + varNameleft, null);
					Tab.insert(Obj.Var, varName, varType);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarPart",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // VarDeclList ::= VarPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // VarDeclList ::= VarDeclList COMMA VarPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // VarDecl ::= Type error COMMA 
            {
              Object RESULT =null;
		 parser.log.debug("Uspesan oporavak od greske do , pri definiciji globalne promenljive."); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // VarDecl ::= Type error SEMI 
            {
              Object RESULT =null;
		 parser.log.debug("Uspesan oporavak od greske do ; pri definiciji globalne promenljive."); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // VarDecl ::= Type NT$1 VarDeclList SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // NT$1 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 varType = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ConstOpt ::= BOOL_CONST 
            {
              Struct RESULT =null;
		 RESULT = parser.boolType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstOpt",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // ConstOpt ::= CHAR_CONST 
            {
              Struct RESULT =null;
		 RESULT = Tab.charType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstOpt",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ConstOpt ::= NUM_CONST 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
			 	tempConstInt = i.intValue();
			 	RESULT = Tab.intType; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstOpt",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ConstPart ::= IDENT EQUAL ConstOpt 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int cnstleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int cnstright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct cnst = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				this.parser.globalConstCnt++;
			  	Obj temp = Tab.currentScope().findSymbol(varName);
				if (temp != null) {
					parser.report_error("Greska na liniji " + varNameleft + ": konstanta " + varName + " je vec deklarisana", null);
				}
				else if (!cnst.assignableTo(constType)) {
					parser.report_error("Greska na liniji " + varNameleft + ": nekompatabilni tipovi pri dodeli konstante", null);
				}
				else {
					parser.report_info("Deklarisana konstanta " + varName + " na liniji " + varNameleft, null);
					Obj obj = Tab.insert(Obj.Con, varName, constType);
					obj.setAdr(tempConstInt);
				}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstPart",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ConstDeclList ::= ConstPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclList",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ConstDeclList ::= ConstDeclList COMMA ConstPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclList",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // ConstDecl ::= CONST error SEMI 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 parser.report_info("Uspesan oporavak od greske do ; prilikom definicije konstanti na liniji " + eleft, null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ConstDecl ::= CONST Type NT$0 ConstDeclList SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // NT$0 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 constType = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // Decl ::= ClassDecl 
            {
              Object RESULT =null;
		 this.parser.classCnt++; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // Decl ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Decl ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // DeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // DeclList ::= DeclList Decl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ProgName ::= IDENT 
            {
              Obj RESULT =null;
		int pNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int pNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String pName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
				Tab.openScope();
				currentScope++; 
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgName",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= PROG ProgName DeclList LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
				Code.dataSize = Tab.currentScope().getnVars();
				Tab.chainLocalSymbols(p);
				Tab.closeScope();
				currentScope--;
				if (!mainDeclared) {
					parser.report_error("Greska: u programu ne postoji metoda sa imenom main!", null);
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

